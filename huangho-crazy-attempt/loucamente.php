<?php

error_reporting(E_ALL | E_STRICT);
session_start();

# Magic quoting sucks.
function unquote($txt) {
	if (get_magic_quotes_gpc())
		return stripslashes($txt);
	else
		return $txt;
}

class User {
	public $email;     # String; primary key
	public $cpf;       # String (não cabe num int, nem inventem)
	public $name;      # String
	public $address;   # String
	public $phone;     # String
	public $password;  # String

	public $bankName;
	public $bankAgency;
	public $bankAccountNumber;

	# TODO: Write a decent constructor. Ideally callers should not rely on
	# argument order.
}

class Product {
	public $id;       # Int; primary key; autogenerated
	public $title;
	public $author;
	public $year;
	public $edition;
	public $conservationState;
	public $warranty;
	public $deliveryModes;
	public $price;
	public $notes;

	public $owner;
}

class Cart {
	public $items = Array();

	function addItem($id) {
		if (!$this->hasItem($id))
			array_push($this->items, $id);
	}

	function getItems() {
		return $this->items;
	}

	function getItemCount() {
		return count($this->items);
	}

	function removeItem($id) {
		if (($key = array_search($id, $this->items)) !== FALSE) {
			unset($this->items[$key]);
			return TRUE;
		}
		else
			return FALSE;
	}

	function hasItem($id) {
		return in_array($id, $this->items);
	}

	function reset() {
		$this->items = Array();
	}
}


// "Pedido" (conjunto de transações do mesmo carrinho)
class Order {
	public $id;
	public $buyerId;
	public $time;

	function __construct($buyerId=NULL, $time=NULL) {
		if (func_num_args() > 0) {
			$this->buyerId = $buyerId;
			$this->time = $time;
		}
	}
}

// Transação de um produto individual.
class Transaction {
	public $id;
	public $productId;
	public $orderId;
	public $status;    # waitingPayment, waitingShipment, waitingConfirmation, concluded

	function __construct($productId=NULL, $orderId=NULL, $status=NULL) {
		if (func_num_args() > 0) {
			$this->productId = $productId;
			$this->orderId = $orderId;
			$this->status = $status;
		}
	}
}


class DataBase {
	public $pdo;

	function createTable($name, $attributes) {
		// [TODO: Set primary key.]
		// DONE, in the most gambiarrous way.

		$cmd = "CREATE TABLE $name (";
		
		if (($idpos = array_search("id", $attributes)) !== FALSE) {
			$cmd .= "id integer primary key";
			unset($attributes[$idpos]);
		}
		else {
			$cmd .= $attributes[0] . " primary key";
			array_shift($attributes);
		}

		foreach ($attributes as $attr)
			$cmd .= ", $attr";

		$cmd .=  ")";
		$this->pdo->exec($cmd);
	}

	function insertInto($table, $object) {
		$colon_keys = Array();
		$keys = Array();
		$values = Array();
		foreach (get_object_vars($object) as $key => $value) {
			if ($value !== NULL) {
				array_push($keys, $key);
				array_push($colon_keys, ":$key");
				$values[":$key"] = $value;
			}
		}

		$query = $this->pdo->prepare("INSERT INTO $table (" . implode(",", $keys) . ") VALUES (" . implode(",", $colon_keys) . ")");
		print_r($this->pdo->errorInfo());
		$query->execute($values);
		print_r($this->pdo->errorInfo());
		return $this->pdo->lastInsertId();
	}

	function dumpTable($table) {
		return $this->pdo->query("SELECT * FROM $table")->fetchAll();
	}
}


// Merging UserBase and ProductBase into a single class. Is this really what we want? 
// (Otherwise we can't use foreign keys from one to the other.)
// TODO: Find a better name (perhaps).

class EulojaBase extends DataBase {
	function __construct() {
		$this->pdo = new PDO('sqlite:dbase.sqlite');
		$this->createTable('Users', array_keys(get_class_vars('User')));
		$this->createTable('Products', array_keys(get_class_vars('Product')));
		$this->createTable('Orders', array_keys(get_class_vars('Order')));
		$this->createTable('Transactions', array_keys(get_class_vars('Transaction')));

		print_r($this->pdo->errorInfo());
	}

	function findUserByEmail($email) {
		$query = $this->pdo->prepare('SELECT * from Users where email = :email');
		$query->execute(Array(':email' => $email));
		return $query->fetchObject('User');
	}

	function findUserByCPF($cpf) {
		$query = $this->pdo->prepare('SELECT * from Users where cpf = :cpf');
		$query->execute(Array(':cpf' => $cpf));
		return $query->fetchObject('User');
	}

	function findProductById($id) {
		$query = $this->pdo->prepare('SELECT * from Products where id = :id');
		$query->execute(Array(':id' => $id));
		return $query->fetchObject('Product');
	}

	function queryOrdersByUser($userEmail) {
		$query = $this->pdo->prepare('SELECT * from Orders where buyerId = :id');
		$query->execute(Array(':id' => $userEmail));
		return $query;  // Hrrgh.
	}

	function queryTransactionsByOrder($orderId) {
		$query = $this->pdo->prepare('SELECT * from Transactions where orderId = :id');
		$query->execute(Array(':id' => $orderId));
		return $query;
	}

	function addUser($user) {
		return $this->insertInto('Users', $user);
	}

	function addProduct($product) {
		return $this->insertInto('Products', $product);
	}

	function addOrder($order) {
		return $this->insertInto('Orders', $order);
	}

	function addTransaction($transaction) {
		return $this->insertInto('Transactions', $transaction);
	}


}

///class ProductBase extends DataBase{
///	// µµµ.
///}

class Session {
	public $userEmail;
	public $cart;

	function __construct() {
		$this->cart = new Cart();
	}
}

class MainController {
	public $dbase;
	public $session;

	function __construct() {
		$this->dbase = new EulojaBase();
	}

	function init() {
		if (!isset($_SESSION['session']))
			$_SESSION['session'] = new Session();
		$this->session = $_SESSION['session'];

		if (isset($_REQUEST['loginAction']))
			$loginAction = $_REQUEST['loginAction'];
		else
			$loginAction = 'none';

		if (isset($_REQUEST['action']))
			$action = $_REQUEST['action'];
		else
			$action = 'home';

		// Take this away later.
		echo "<A HREF='loucamente.php'>Home</A><BR>\n";

		// Check for a pending login action.
		switch ($loginAction) {
			case 'login':
				# TODO [DONE]: if loginAction is 'login' and user is already logged in,
				# it might be better to just ignore the preaction, so that actions
				# that require logging in can safely set loginAction to 'login',
				# whether or not the user is already logged in. Yea?

				if (!$this->session->userEmail) {
					$login = new LoginController($this->dbase, $action);
					$user = $login->authenticate();
					if ($user)
						$this->session->userEmail = $user->email;
					else
						return;  ## Bad!!
				}
				break;

			case 'logout':
				$this->session->userEmail = NULL;
				break;
		}

		// Then perform the main action.
		switch ($action) {
			case 'addUser':
				$addUser = new AddUserController($this->dbase);
				$addUser->act();
				break;

			case 'addProduct':
				$addProduct = new AddProductController($this->dbase, $this->session);
				$addProduct->act();
				break;

			case 'searchProduct':
				$searchProduct = new SearchProductController($this->dbase, $this->session);
				$searchProduct->act();
				break;

			case 'viewProduct':
				$viewProduct = new ViewProductController($this->dbase, $this->session, $_REQUEST['id']);
				$viewProduct->act();
				break;

			case 'finishShopping':
				$finishShopping = new FinishShoppingController($this->dbase, $this->session);
				$finishShopping->act();
				break;

			case 'viewOrders':
				$viewOrders = new ViewOrdersController($this->dbase, $this->session);
				$viewOrders->act();
				break;

			case 'dumpAllTables':
				### DEBUG!!
				echo "<PRE>";
				echo "<H3>Users</H3>\n";
				print_r($this->dbase->dumpTable('Users'));
				echo "<H3>Products</H3>\n";
				print_r($this->dbase->dumpTable('Products'));
				echo "<H3>Orders</H3>\n";
				print_r($this->dbase->dumpTable('Orders'));
				echo "<H3>Transactions</H3>\n";
				print_r($this->dbase->dumpTable('Transactions'));
				echo "</PRE>";
				break;

			case 'home':
				$this->home();
				break;

			default:
				echo "WTF is $action?\n";
		}

	}

	function home() {
		// This goes to its own controller, one day in the future.
		if ($this->session->userEmail)
			echo "<P>Logged in as " . $this->session->userEmail . "\n";
		else
			echo "<P>Not logged in.\n";

		?>
			<UL>
				<LI><A HREF="loucamente.php?action=addUser">Adicionar usuário</A>
				<LI><A HREF="loucamente.php?action=addProduct&amp;loginAction=login">Adicionar produto</A>
				<LI><A HREF="loucamente.php?action=searchProduct">Pesquisar produtos</A>
				<LI><A HREF="loucamente.php?action=finishShopping&amp;loginAction=login">Encerrar compras</A>
				<LI><A HREF="loucamente.php?action=viewOrders&amp;loginAction=login">Ver pedidos</A>
				<LI><A HREF="loucamente.php?action=dumpAllTables">Dump all tables (DEBUG)</A>
				<LI><A HREF="loucamente.php?action=home&amp;loginAction=login">Login</A>
				<LI><A HREF="loucamente.php?action=home&amp;loginAction=logout">Logout</A>
			</UL>
		<?php
	}

}

// HTML form attribute.
class Attribute {
	public $key;
	public $label;
	public $defaultValue;
	public $value;
	public $isMandatory;

	function __construct($key, $label, $type='text', $isMandatory=FALSE, $defaultValue=NULL) {
		$this->key = $key;
		$this->label = $label;
		$this->type = $type;
		$this->defaultValue = $defaultValue;
		$this->isMandatory = $isMandatory;

		# Questionable.
		if (isset($_REQUEST[$key]))
			$this->value = unquote($_REQUEST[$key]); // Grab current value from HTTP request.
		else
			$this->value = $this->defaultValue;
	}

	function printHTML() {
		$value = htmlspecialchars($this->value, ENT_QUOTES);
		echo "<TR><TD>{$this->label}<TD><INPUT TYPE='{$this->type}' NAME='{$this->key}' VALUE='$value'>\n";
	}
}

class UIForm {
	public $attributes = Array();
	public $action;
	public $method = 'POST';
	public $errors = Array();
	public $actionSuffix = "";

	function __construct() {
		$this->action = $_SERVER['REQUEST_URI'];  // Half-bad.
		$this->action .= $this->actionSuffix;     // Full-bad.
	}

	function inMidAction() {
		return isset($_REQUEST['mid_action']);
	}

	function addAttribute($attr) {
		// Assuming PHP will keep array order.
		$this->attributes[$attr->key] = $attr;
		
		// Cannot use call_user_func_array with constructor. (Why not? You can't, that's why.)
	}

	function getAttributeValue($key) {
		return $this->attributes[$key]->value;
	}

	function addError($error) {
		array_push($this->errors, $error);
	}

	function printHTML() {
		echo "<FORM ACTION='{$this->action}' METHOD='{$this->method}'>\n";
		echo "<TABLE>\n";

		foreach ($this->errors as $error) {
			echo "<P>ERRO: $error";
		}

		foreach ($this->attributes as $attr) {
			$attr->printHTML();
		}
		echo "</TABLE>\n";
		echo "<INPUT TYPE='Submit' VALUE='Manda bala'>\n";
		echo "</FORM>\n";
	}

	function checkMandatory() {
		$allOK = TRUE;
		foreach ($this->attributes as $attr) {
			if ($attr->isMandatory && !$this->getAttributeValue($attr->key)) {
				# TODO: Perhaps separate check logic from messages?
				$this->addError("Campo '{$attr->label}' é obrigatório!");
				$allOK = FALSE;
			}
		}
		return $allOK;
	}
}

class LoginForm extends UIForm {
	public $errorStatus = NULL;
	public $postLoginAction = NULL;

	function __construct($postLoginAction=NULL) {
		parent::__construct();
		$this->postLoginAction = $postLoginAction;

		$this->addAttribute(new Attribute("email", "E-mail"));
		$this->addAttribute(new Attribute("password", "Password", "password"));
	}

	function printHTML() {
		if ($this->postLoginAction && $this->postLoginAction != 'home') {
			echo "<H2>Þu þarft að skrá inn til að halda áfram!</H2>\n";
		}
		if ($this->errorStatus) {
			echo "<P>Erro de autenticação: {$this->errorStatus}";
		}
		parent::printHTML();
	}
}

class LoginController {
	public $ui;
	public $postLoginAction;
	public $userBase;

	function __construct($userBase, $action) {
		$this->ui = new LoginForm($action);
		$this->userBase = $userBase;
		$this->postLoginAction = $action;
	}

	function authenticate() {
		if ($email = $this->ui->getAttributeValue('email')) {
			// We are mid-login.
			$user = $this->userBase->findUserByEmail($email);
			if ($user) {
				$formPassword = $this->ui->getAttributeValue('password');
				if ($user->password == $formPassword) {
					return $user;
				}
				else {
					$this->ui->errorStatus = 'WRONG_PASSWORD';
				}
			}
			else {
				$this->ui->errorStatus = 'UNKNOWN_USER';
			}
		}

		$this->ui->printHTML();
	}

}

class AddUserForm extends UIForm {
	public $errorStatus;

	function __construct() {
		$this->actionSuffix = '&amp;mid_action=1';
		parent::__construct();

		$this->addAttribute(new Attribute('name', "Nome completo", 'text', TRUE));
		$this->addAttribute(new Attribute('cpf', "CPF", 'text', TRUE));
		$this->addAttribute(new Attribute('email', "E-mail", 'text', TRUE));
		$this->addAttribute(new Attribute('address', "Endereço", 'text', TRUE));
		$this->addAttribute(new Attribute('phone', "Telefone", 'text', TRUE));
		$this->addAttribute(new Attribute('password', "Senha", 'password', TRUE));
		$this->addAttribute(new Attribute('password_confirmation', "Confirme a senha", 'password', TRUE));
	}

	function printHTML() {
		if ($this->errorStatus) {
			echo "<P>Error adding user: {$this->errorStatus}\n";
		}
		parent::printHTML();
	}

}

class AddUserController {
	public $ui;
	public $userBase;

	function __construct($userBase) {
		$this->ui = new AddUserForm();
		$this->userBase = $userBase;
	}

	function act() {
		if ($this->ui->inMidAction()) {
			if ($this->validate()) {
				# TODO: Have a decent constructor.
				$user = new User();
				$user->name = $this->ui->getAttributeValue('name');
				$user->email = $this->ui->getAttributeValue('email');
				$user->cpf = $this->ui->getAttributeValue('cpf');
				$user->address = $this->ui->getAttributeValue('address');
				$user->phone = $this->ui->getAttributeValue('phone');
				$user->password = $this->ui->getAttributeValue('password');
				if ($this->userBase->addUser($user)) {
					echo "<P>Yay! <A HREF='loucamente.php?action=home'>Home</A>";
					return TRUE;
				}
				else {
					echo "Fail!\n";
				}
			}
		}
		$this->ui->printHTML();
	}

	function validate() {
		$this->ui->checkMandatory();

		# We check this here, rather than in addUser, because we want to inform
		# the user as soon as possible that his/her CPF/e-mail is already registered.
		$email=""; $cpf="";
		if (($cpf = $this->ui->getAttributeValue('cpf')) && $this->userBase->findUserByCPF($cpf))
			$this->ui->addError("CPF já cadastrado!");

		if (($email = $this->ui->getAttributeValue('email')) && $this->userBase->findUserByEmail($email))
			$this->ui->addError("E-mail já cadastrado!");


		$pass1 = $this->ui->getAttributeValue('password');
		$pass2 = $this->ui->getAttributeValue('password_confirmation');
		if ($pass1 != $pass2) {
			$this->ui->addError("Senha e confirmação não casam!");
			return FALSE;
		}

		return (count($this->ui->errors) == 0);
	}
}

class AddProductController {
	public $ui;
	public $dbase;
	public $session;

	function __construct($dbase, $session) {
		$this->dbase = $dbase;
		$this->session = $session;
		$this->ui = new AddProductForm();
	}

	function act() {
		// This one is very similar to AddUserController::act. Refactor?
		if ($this->ui->inMidAction()) {
			if ($this->validate()) {
				$product = new Product();
				$product->title = $this->ui->getAttributeValue('title');
				$product->author = $this->ui->getAttributeValue('author');
				$product->year = $this->ui->getAttributeValue('year');
				$product->edition = $this->ui->getAttributeValue('edition');
				$product->conservationState = $this->ui->getAttributeValue('conservationState');
				$product->warranty = $this->ui->getAttributeValue('warranty');
				$product->deliveryModes = $this->ui->getAttributeValue('deliveryModes');
				$product->price = $this->ui->getAttributeValue('price');
				$product->notes = $this->ui->getAttributeValue('notes');

				$product->owner = $this->session->userEmail;

				if ($id = $this->dbase->addProduct($product)) {
					echo "<P>Yay! (product id $id) <A HREF='loucamente.php?action=home'>Home</A>";
					return TRUE;
				}
				else {
					echo "Fail!\n";
				}
			}
		}
		$this->ui->printHTML();
	}

	function validate() {
		return $this->ui->checkMandatory();
	}
}

class AddProductForm extends UIForm {
	function __construct() {
		$this->actionSuffix = '&amp;mid_action=1';
		parent::__construct();

		$this->addAttribute(new Attribute('title', "Título", 'text', TRUE));
		$this->addAttribute(new Attribute('author', "Autor", 'text', TRUE));
		$this->addAttribute(new Attribute('year', "Ano", 'text', FALSE));
		$this->addAttribute(new Attribute('edition', "Edição", 'text', FALSE));

		// TODO: radioboxes and the likes
		$this->addAttribute(new Attribute('conservationState', "Estado de conservação", 'text', FALSE));
		$this->addAttribute(new Attribute('warranty', "Garantia", 'text', FALSE));
		$this->addAttribute(new Attribute('deliveryModes', "Modos de entrega", 'text', FALSE));

		$this->addAttribute(new Attribute('price', "Preço", 'text', TRUE));

		// TODO: textarea
		$this->addAttribute(new Attribute('notes', "Notas", 'text', FALSE));
	}

}

class SearchProductController {
	public $form;
	public $dbase;
	public $session;

	function __construct($dbase, $session) {
		$this->form = new SearchProductForm();
		$this->dbase = $dbase;
		$this->session = $session;
	}

	function act() {
		if ($this->form->inMidAction()) {
			$queryArgs = Array();
			$author = $this->form->getAttributeValue('author');
			$priceLowerBound = $this->form->getAttributeValue('priceLowerBound');
			$priceUpperBound = $this->form->getAttributeValue('priceUpperBound');

			$queryText = 'SELECT * FROM Products ';
			$constraints = Array();

			if ($title = $this->form->getAttributeValue('title')) {
				$constraints[] = 'title LIKE :title';
				$queryArgs[':title'] = "%$title%"; // TODO: escape wildchars (lamentável)
			}

			if ($author = $this->form->getAttributeValue('author')) {
				$constraints[] = 'author LIKE :author';
				$queryArgs[':author'] = "%$author%";  // TODO: escape wildchars (lamentável)
			}

			if ($priceLowerBound = $this->form->getAttributeValue('priceLowerBound')) {
				// GAMBIARRA; should set column type to numeric, instead of casting.
				$constraints[] = 'cast(price as float) >= cast(:priceLowerBound as float)';
				$queryArgs[':priceLowerBound'] = $priceLowerBound;
			}

			if ($priceUpperBound = $this->form->getAttributeValue('priceUpperBound')) {
				// GAMBIARRA; should set column type to numeric, instead of casting.
				$constraints[] = 'cast(price as float) <= cast(:priceUpperBound as float)';
				$queryArgs[':priceUpperBound'] = $priceUpperBound;
			}

			if ($constraints)
				$queryText .= 'where ' . implode(" AND ", $constraints);

			echo "$queryText\n";
			$query = $this->dbase->pdo->prepare($queryText);
			if (!$query)
				print_r($this->dbase->pdo->errorInfo());
			$query->execute($queryArgs);

			$this->showResults($query);

		}
		else {
			$this->form->printHTML();
		}
	}

	function showResults($query) {
		// TODO: Currently this fetches the whole results every time
		// (which would be bad if we paginated the results).

		$itemCount = 0;

		echo "<TABLE>\n";
		echo "<TR CLASS='titleRow'><TH>Título<TH>Autor<TH>Preço\n";

		while ($product = $query->fetchObject('Product')) {
			$itemCount++;
			echo "<TR CLASS='" . ($itemCount%2? 'oddRow' : 'evenRow') . "'>\n"
			   . "<TD><A HREF='loucamente.php?action=viewProduct&amp;id={$product->id}'>"
			   . htmlspecialchars($product->title) . "</A>"
			   . "<TD>" . htmlspecialchars($product->author)
			   . "<TD>" . htmlspecialchars($product->price) . "\n";
		}
		echo "</TABLE>\n";

		if ($itemCount == 0) {
			echo "<P>Yo no lo conozco, señor!\n";
		}
	}
}

class SearchProductForm extends UIForm {
	function __construct() {
		$this->actionSuffix = '&amp;mid_action=1';
		parent::__construct();
		$this->addAttribute(new Attribute('title', "Título", 'text'));
		$this->addAttribute(new Attribute('author', "Autor", 'text'));
		$this->addAttribute(new Attribute('priceLowerBound', "Preço>=", 'text'));
		$this->addAttribute(new Attribute('priceUpperBound', "Preço<=", 'text'));
	}

	#function printHTML() {
	#	
	#}

}

class ViewProductController {
	public $session;
	public $dbase;
	public $id;
	public $ui;
	public $product;

	function __construct($dbase, $session, $id) {
		$this->dbase = $dbase;
		$this->session = $session;
		$this->id = $id;

		$this->product = $dbase->findProductById($id);
		if (!$this->product) {
			echo "Fail! ($id)\n";
		}

		$this->ui = new ViewProductUI($this->product);
	}

	function act() {
		if ($this->ui->cartAction() == 'add') {
			$this->session->cart->addItem($this->id);
		}
		else if ($this->ui->cartAction() == 'remove') {
			$this->session->cart->removeItem($this->id);
		}

		// DEBUG
		echo "Hay " . $this->session->cart->getItemCount() . " itens nel carriño.\n";
		print_r($this->session->cart->getItems());

		$this->ui->inCart = $this->session->cart->hasItem($this->id);

		$this->ui->printHTML();
	}
}

class ViewProductUI {
	// This is not a form! (Or a pipe, for instance.)
	public $product;
	public $inCart;

	function __construct($product, $inCart=FALSE) {
		$this->product = $product;
		$this->inCart = $inCart;
	}

	function printHTML() {
		echo "<PRE>\n";
		print_r($this->product);
		echo "</PRE>\n";

		if (!$this->inCart)
			echo "<P><A HREF='$_SERVER[REQUEST_URI]&amp;cart=add'>[Añade al carriño]</A>";
		else
			echo "<P><A HREF='$_SERVER[REQUEST_URI]&amp;cart=remove'>[Remueve del carriño]</A>";
	}

	function cartAction() {
		if (isset($_REQUEST['cart']))
			return $_REQUEST['cart'];
		else
			return NULL;
	}
}

class FinishShoppingController {
	public $dbase;
	public $session;

	function __construct($dbase, $session) {
		$this->dbase = $dbase;
		$this->session = $session;
		$this->ui = new FinishShoppingUI();
		$this->products = Array();
	}

	function act() {
		foreach ($this->session->cart->getItems() as $id) {
			$product = $this->dbase->findProductById($id);
			$this->products[] = $product;
		}

		$this->ui->products = $this->products;

		if ($this->ui->inMidAction()) {
			# In another world, we would have the credit card information
			# from the buyer. Then we would validate it, and only then
			# register the transaction. But this is not another world.

			$orderId = $this->dbase->addOrder(new Order($this->session->userEmail, time())); // Every time I see you falling...
			foreach ($this->products as $product)
				$this->dbase->addTransaction(new Transaction($product->id, $orderId, 'waitingPayment'));

			echo "Yea! (orderId = $orderId)\n";
			$this->session->cart->reset();
		}
		else {
			$this->ui->printHTML();
		}

	}
}

class FinishShoppingUI {
	public $products;

	function printHTML() {
		echo "Camarada, tu escolheste os seguintes produtos:\n";
		echo "<UL>\n";

		foreach ($this->products as $product) {
			echo "<LI><A HREF='loucamente.php?action=viewProduct&amp;id={$product->id}'>" . htmlspecialchars($product->title) . "</A>\n";
		}

		echo "</UL>\n";
		echo "<P>[Inserte formulário com opções de pagamento aquí]\n";
		echo "<P><A HREF='loucamente.php?action=finishShopping&mid_action=1'>[Manda bala]</A>\n";

	}

	function inMidAction() {
		return isset($_REQUEST['mid_action']);
	}
}

class ViewOrdersController {
	public $dbase;
	public $session;

	function __construct($dbase, $session) {
		$this->dbase = $dbase;
		$this->session = $session;
		$this->ui = new ViewOrdersUI();
	}

	function act() {
		$orderQuery = $this->dbase->queryOrdersByUser($this->session->userEmail);

		// This should be in the UI. And it should be decent.

		while ($order = $orderQuery->fetchObject('Order')) {
			echo "<H3>Order {$order->id}</H3>";
			$transactionQuery = $this->dbase->queryTransactionsByOrder($order->id);
			while ($transaction = $transactionQuery->fetchObject('Transaction')) {
				echo "<PRE>";
				print_r($transaction);
				echo "</PRE>\n";
			}
		}

		//echo "<PRE>\n";
		//print_r($query->fetchAll());
		//echo "</PRE>\n";

		$this->ui->printHTML();
	}
}

class ViewOrdersUI {
	function printHTML() {
		echo "Hello, sailor!\n";
	}
}

?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="Content-type" CONTENT="text/html; charset=UTF-8">
	<TITLE>Euloja</TITLE>
	<LINK REL="stylesheet" TYPE="text/css" HREF="euloja.css">
</HEAD>
<BODY>
<?php

$main = new MainController();
$main->init();

?>
</BODY>
</HTML>
